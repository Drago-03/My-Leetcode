# My-Leetcode

Welcome to My-Leetcode, a comprehensive repository of my solutions to various LeetCode problems. Each problem is meticulously solved in Python and includes a detailed description of the problem and its constraints. The solutions are organized by problem number and include a concise explanation of the approach used.

## Problem List

* [1. Two Sum](1.py): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
* [2. Add Two Numbers](2.py): You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
* [3. Longest Substring Without Repeating Characters](3.py): Given a string s, find the length of the longest substring without repeating characters.
* [4. Median of Two Sorted Arrays](4.py): Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
* [5. Longest Palindromic Substring](5.py): Given a string s, return the longest palindromic substring in s.
* [6. Zigzag Conversion](6.py): The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) Then read the characters diagonally from top to bottom and from left to right to obtain the string "PAHNAPLSIIGYIR".
* [7. Reverse Integer](7.py): Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.
* [8. String to Integer (atoi)](8.py): Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.
* [9. Palindrome Number](9.py): Given an integer x, return true if x is a palindrome, and false otherwise.
* [10. Regular Expression Matching](10.py): Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:
* [11. Container With Most Water](11.py): You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the i-th line are (i, height[i]).
* [12. Integer to Roman](12.py): Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
* [13. Roman to Integer](13.py): Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
* [14. Longest Common Prefix](14.py): Write a function to find the longest common prefix string amongst an array of strings.
* [15. 3Sum](15.py): Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
* [16. 3Sum Closest](16.py): Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
* [17. Letter Combinations of a Phone Number](17.py): Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
* [18. 4Sum](18.py): Given an array nums of n integers, return all unique quadruplets in the given array which gives the sum of four 32-bit integers equal to zero.
* [19. Remove Nth Node From End of List](19.py): Given the head of a linked list, remove the nth node from the end of the list and return its head.
* [20. Valid Parentheses](20.py): Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
* [21. Merge Two Sorted Lists](21.py): Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.
* [22. Generate Parentheses](22.py): Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
* [23. Merge k Sorted Lists](23.py): Merge k sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first k lists.
* [24. Swap Nodes in Pairs](24.py): Given a linked list, swap every two adjacent nodes and return its head.
* [25. Reverse Nodes in k-Group](25.py): Given a linked list, reverse the nodes of k-group and return its head.
* [26. Remove Duplicates from Sorted Array](26.py): Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.
* [27. Remove Element](27.py): Given an array nums and a value val, remove all instances of that value in-place and return the new length.
* [28. Implement strStr()](28.py): Implement strStr() function, which returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
* [29. Divide Two Integers](29.py): Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
* [30. Substring with Concatenation of All Words](30.py): You are given a string s and a list of words words, where each word is the same length. Find all starting indices of substrings in s that are a concatenation of each word in words exactly once, without any intervening characters.
* [31. Next Permutation](31.py): Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
* [32. Longest Valid Parentheses](32.py): Given a string containing just the characters '(', ')', '{', '}', '[' and ']', find the length of the longest valid parentheses sequence.
* [33. Search in Rotated Sorted Array](33.py): Suppose an array of length n is rotated between 1 and n times. For example, the array [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]. Given the sorted rotated array nums of unique elements, return the index of the given target if it is in nums, or -1 if it is not in nums.
* [34. Find First and Last Position of Element in Sorted Array](34.py): Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
* [35. Search Insert Position](35.py): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it should be inserted to maintain the sorted order.
* [36. Valid Sudoku](36.py): Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
* [37. Sudoku Solver](37.py): Write a program to solve a Sudoku puzzle by filling the empty cells.
* [38. Count and Say](38.py): The count-and-say sequence is the sequence of integers with the first five terms as following:
* [39. Combination Sum](39.py): Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums up to target.
* [40. Combination Sum II](40.py): Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums up to target.
* [41. First Missing Positive](41.py): Given an unsorted integer array, find the smallest missing positive integer.
* [42. Trapping Rain Water](42.py): Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the total area of water it can contain is maximized.
* [43. Multiply Strings](43.py): Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.
* [44. Wildcard Matching](44.py): Implement wildcard pattern matching with the following special characters:
* [45. Jump Game II](45.py): Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.
* [46. Permutations](46.py): Given a collection of distinct integers, return all possible permutations.
* [47. Permutations II](47.py): Given a collection of numbers that might contain duplicates, return all possible unique permutations.
* [48. Rotate Image](48.py): You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).
* [49. Group Anagrams](49.py): Given an array of strings, group the anagrams together.
* [50. Pow(x, n)](50.py): Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
* [51. N-Queens](51.py): The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
* [52. N-Queens II](52.py): The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
* [53. Maximum Subarray](53.py): Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
* [54. Spiral Matrix](54.py): Given a matrix, spiral order means starting from the top left, going right, then down, then left, then up, and so on.
* [55. Jump Game](55.py): Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you are able to reach the last index in the array.
* [56. Merge Intervals](56.py): Given a collection of intervals, merge all overlapping intervals.
* [57. Insert Interval](57.py): Given a set of non-overlapping intervals, insert a new interval [newStart, newEnd] into the intervals (merge if necessary).
* [58. Length of Last Word](58.py): Given a string s consists of some words separated by some number of spaces, return the length of the last word in the string.
* [59. Spiral Matrix II](59.py): Given a positive integer n, generate a spiral matrix.
* [60. Permutation Sequence](60.py): The set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence (ie, for n = 3):
* [61. Rotate List](61.py): Given a linked list, rotate the list to the right by k places, where k is non-negative.
* [62. Unique Paths](62.py): A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there for the robot to reach the finish?
* [63. Unique Paths II](63.py): A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?
* [64. Minimum Path Sum](64.py): Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
* [65. Valid Number](65.py): Validate if a given string can be interpreted as a decimal or an integer.
* [66. Plus One](66.py): Given a non-negative integer num, plus one to num.
* [67. Add Binary](67.py): Given two binary strings, return their sum (also a binary string).
* [68. Text Justification](68.py): Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.
* [69. Sqrt(x)](69.py): Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
* [70. Climbing Stairs](70.py): You are climbing a stair case. At each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
* [71. Simplify Path](71.py): Given a string path, simplify it.
* [72. Edit Distance](72.py): Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.
* [73. Set Matrix Zeroes](73.py): Given a m x n matrix, if an element is 0, set its entire row and column to zeros, and return the modified matrix.
* [74. Search a 2D Matrix](74.py): Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
* [75. Sort Colors](75.py): Given an array with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
* [76. Minimum Window Substring](76.py): Given two strings s and t of lengths m and n, return the minimum window in s which contains all the characters of t, if such window exists. If not, return an empty string.
* [77. Combinations](77.py): Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
* [78. Subsets](78.py): Given a set of distinct integers, nums, return all possible subsets (the power set).
* [79. Word Search](79.py): Given a 2D board and a word, find if the word exists in the grid.
* [80. Remove Duplicates from Sorted Array II](80.py): Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and returns the new length.
* [81. Search in Rotated Sorted Array II](81.py): Suppose an array of length n is rotated between 1 and n times. For example, the array [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]. Given the sorted rotated array nums of unique elements, return the index of the given target if it is in nums, or -1 if it is not in nums.
* [82. Remove Duplicates from Sorted List II](82.py): Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.
* [83. Remove Duplicates from Sorted List](83.py): Given a sorted linked list, delete all duplicates such that each element appears only once and returns the modified list.
* [84. Largest Rectangle in Histogram](84.py): Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the total area of water it can contain is maximized.
* [85. Maximal Rectangle](85.py): Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
* [86. Partition List](86.py): Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
* [87. Scramble String](87.py): We can scramble a string s to get a string t if the letters in t are a permutation of the letters in s, ignoring the order of the letters.
* [88. Merge Sorted Array](88.py): Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
* [89. Gray Code](89.py): The gray code is a sequence of numbers in which every pair of adjacent numbers differs in exactly one bit.
* [90. Subsets II](90.py): Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
* [91. Decode Ways](91.py): A message containing letters from A-Z is being encoded to numbers using the following mapping:
* [92. Reverse Linked List II](92.py): Reverse a linked list from position m to n. Do it in-place and in one-pass.
* [93. Restore IP Addresses](93.py): Given a string containing only digits, restore it by inserting some separation characters or remove characters so that the resulting string satisfies a certain pattern.
* [94. Binary Tree Inorder Traversal](94.py): Given a binary tree, return the inorder traversal of its nodes' values.
* [95. Unique Binary Search Trees II](95.py): Given an integer n, generate all structurally unique BSTs (binary search trees) that store values 1 ... n.
* [96. Unique Binary Search Trees](96.py): Given n, how many structurally unique BSTs (binary search trees) that store values 1 ... n?
* [97. Interleaving String](97.py): Given three strings: s1, s2, s3, determine if s3 is formed by the interleaving of s1 and s2.
* [98. Validate Binary Search Tree](98.py): Given a binary tree, determine if it is a valid binary search tree (BST).
* [99. Recover Binary Search Tree](99.py): Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.
* [100. Same Tree](100.py): Given two binary trees, write a function to check if they are the same or not.
* [101. Symmetric Tree](101.py): Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
* [102. Binary Tree Level Order Traversal](102.py): Given a binary tree, return the level order traversal of its nodes' values.
* [103. Binary Tree Zigzag Level Order Traversal](103.py): Given a binary tree, return the zigzag level order traversal of its nodes' values.
* [104. Maximum Depth of Binary Tree](104.py): Given a binary tree, find its maximum depth.
* [105. Construct Binary Tree from Preorder and Inorder Traversal](105.py): Given preorder and inorder traversal of a tree, construct the binary tree.
* [106. Construct Binary Tree from Inorder and Postorder Traversal](106.py): Given inorder and postorder traversal of a tree, construct the binary tree.
* [107. Binary Tree Level Order Traversal II](107.py): Given a binary tree, return the bottom-up level order traversal of its nodes' values.
* [108. Convert Sorted Array to Binary Search Tree](108.py): Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
* [109. Convert Sorted List to Binary Search Tree](109.py): Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
* [110. Balanced Binary Tree](110.py): Given a binary tree, determine if it is height-balanced.
* [111. Minimum Depth of Binary Tree](111.py): Given a binary tree, find its minimum depth.
* [112. Path Sum](112.py): Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
* [113. Path Sum II](113.py): Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
* [114. Flatten Binary Tree to Linked List](114.py): Flatten a binary tree to a singly linked list.
* [115. Distinct Subsequences](115.py): Given a string S and a string T, count the number of distinct subsequences of T in S.
* [116. Populating Next Right Pointers in Each Node](116.py): You are given a perfect binary tree where all leaves are at the same level, and every parent node has two children. Populate each next pointer to point to its next right node. If such a node exists, there are no next pointers that should be set to NULL. Initially, all next pointers are set to NULL.
* [117. Populating Next Right Pointers in Each Node II](117.py): Given a binary tree, populate each next pointer to point to its next right node. If such a node exists, there are no next pointers that should be set to NULL. Initially, all next pointers are set to NULL.
* [118. Pascal's Triangle](118.py): Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.
* [119. Pascal's Triangle II](119.py): Given a non-negative index k where k ≤ 33, return the k-th index row of the Pascal's triangle.
* [120. Triangle](120.py): Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
* [121. Best Time to Buy and Sell Stock](121.py): Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
* [122. Best Time to Buy and Sell Stock II](122.py): Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy and sell stock as many times as you like).
* [123. Best Time to Buy and Sell Stock III](123.py): Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions.
* [124. Binary Tree Maximum Path Sum](124.py): Given a non-empty binary tree, find the maximum path sum. For this problem, a path is considered as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
* [125. Valid Palindrome](125.py): Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
* [126. Word Ladder II](126.py): Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequences from beginWord to endWord, such that:
* [127. Word Ladder](127.py): Given two words (beginWord and endWord), and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord, such that:
* [128. Longest Consecutive Sequence](128.py): Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
* [129. Sum Root to Leaf Numbers](129.py): You are given the root of a binary tree containing digits from 0-9 only. Each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers.
* [130. Surrounded Regions](130.py): Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.
* [131. Palindrome Partitioning](131.py): Given a string s, partition s such that every substring of the partition is a palindrome.
* [132. Palindrome Partitioning II](132.py): Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.
* [133. Clone Graph](133.py): Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
* [134. Gas Station](134.py): There are N gas stations along a circular route, where the amount of gas at the station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
* [135. Candy](135.py): There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following rules:
* [136. Single Number](136.py): Given a non-empty array of integers, every element appears twice except for one. Find that single number.
* [137. Single Number II](137.py): Given a non-empty array of integers, every element appears three times except for one. Find that single number.
* [138. Copy List with Random Pointer](138.py): A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.
* [139. Word Break](139.py): Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
* [140. Word Break II](140.py): Given a nonempty string s and a dictionary wordDict containing a list of nonempty words, add spaces in s to construct a sentence where each word is a valid word in wordDict. Return all such possible sentences.
* [141. Linked List Cycle](141.py): Given a linked list, determine if it has a cycle in it.
* [142. Linked List Cycle II](142.py): Given a linked list, return the node where the cycle starts. If there is no cycle, return null.
* [143. Reorder List](143.py): Given a singly linked list L: L0 → L1 → … → Ln-1 → Ln, reorder it to: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … You may not modify the values in the nodes, only the nodes themselves may be changed.
* [144. Binary Tree Preorder Traversal](144.py): Given a binary tree, return the preorder traversal of its nodes' values.
* [145. Binary Tree Postorder Traversal](145.py): Given a binary tree, return the postorder traversal of its nodes' values.
* [146. LRU Cache](146.py): Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
* [147. Insertion Sort List](147.py): Sort a linked list using insertion sort.
* [148. Sort List](148.py): Sort a linked list in O(n log n) time using constant space complexity.
* [149. Max Points on a Line](149.py): Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.
* [150. Evaluate Reverse Polish Notation](150.py): Evaluate the value of an arithmetic expression in Reverse Polish Notation.
###
